class Solution {
public:
 // brute
// int n,res;
// void solve(int idx,string s1,string s2){
//     if(idx == n){
//         if(s2.find(s1)!=string::npos){
//             res = true;
//         }
//         return;

//     }
//     for(int i = idx;i<n;i++){
//         swap(s1[i],s1[idx]);
//         solve(idx+1,s1,s2);
//         swap(s1[i],s1[idx]);
//         if(res == true) return;
//     }
// }
    bool checkInclusion(string s1, string s2) {

//     //    if(s2.find(s1)!=string::npos) return true;
//     //    return false;

//      n  = s1.length();
//     res =false;
//     solve(0,s1,s2);
//     return res;




// int n = s1.length();
//         int m = s2.length();


//         sort(s1.begin(), s1.end());

//         for (int i = 0; i <= m - n; i++) {
//             string substring = s2.substr(i, n);
//             sort(substring.begin(), substring.end());
//             if (s1 == substring) return true;
//         }

//         return false;


        int n = s1.length();
        int m = s2.length();

        if(n > m) return false;

        vector<int> count1(26, 0), count2(26, 0);

        for(char ch : s1)
            count1[ch - 'a']++;

        int i = 0, j = 0;

        while(j < m) {
            count2[s2[j] - 'a']++;
            if(j - i + 1 > n) {
                count2[s2[i] - 'a']--;
                i++;
            }
            if(count1 == count2) return true;

            j++;
        }

        return false;
    }
};

